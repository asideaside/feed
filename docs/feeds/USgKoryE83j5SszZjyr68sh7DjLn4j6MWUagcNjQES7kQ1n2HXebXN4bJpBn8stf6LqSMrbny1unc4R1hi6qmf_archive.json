{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Deep vs Shallow interfaces in Go","url":"https://tpaschalis.me/shallow-vs-deep-interfaces/","date":1742663402,"author":"/u/hyperTrashPanda","guid":551,"unread":true,"content":"<p>One of the core concepts explored in this book is the distinction between\n“deep” vs “shallow” modules (in the author’s terms a module is any kind of\nabstraction, separated into the user-facing interface and the underlying\nimplementation).</p><p>The author argues that “the best modules are those that provide powerful\nfunctionality yet have simple interfaces”. The argument is  about absolute\nsize, but rather the ratio of utility afforded by the abstraction compared to\nthe size of the abstraction itself, in other words, a cost/benefit tradeoff.</p><p>In our case, the main mechanism for composable abstractions in Go is the\n type, so let’s examine the concept through this lens.</p><p>To me, maybe the best example of a deep interface is .</p><div><div><pre><code></code></pre></div></div><p>It couldn’t possibly get  smaller than that, right? It’s simple enough\nthat you won’t ever need to look it up again. Searching the Go standard library, one will find\n<a href=\"https://cs.opensource.google/search?q=Read%5C(%5Cw%2B%5Cs%5C%5B%5C%5Dbyte%5C)&amp;ss=go%2Fgo\">numerous implementations</a>\nincluding reading from files, from network connections, compressors, ciphers\nand more.</p><p>This abstraction is both easy to understand and use; the docstring tells you\neverything you, as a user, need to know. The underlying implementation can be\nbuffered, may allow reading from streams or remote locations like an S3\nbucket. But crucially, consumers of this API don’t need to worry about \nreading happens — implementation can be deep and non-trivial,\nbut a user doesn’t have to care. Furthermore, it allows for very little\nambiguity when reasoning about what the code does.</p><p>All these properties are  important for core functionality that’s\nused frequently.</p><p>On the other hand, an example of a shallow interface I’ve used recently is from\nthe <a href=\"https://github.com/redis/go-redis\">redis-go</a> client.</p><p>I’ve trimmed it down for the purposes of this post, but you can see it \n<a href=\"https://github.com/redis/go-redis/blob/11efd6a01ebf1c3a0f8cc41d0a1d54c5afbae26f/commands.go#L160-L230\">here</a>\nin its entirety. It contains 45 methods  uses 19 other interfaces as\nextensions for a total of ~200 methods.</p><div><div><pre><code></code></pre></div></div><p>While the functionality provided by Redis is much larger than just ‘reading’,\neach of these methods has a much simpler implementation; they do exactly one\nthing, and they’re small enough you could possibly replicate them just by their\nname and arguments. The ratio of the functionality provided to the size of\nthe abstraction is very different than before.</p><div><div><pre><code></code></pre></div></div><p>This also shifts the responsibility of doing the right thing towards the\nuser, as they have to understand the nuances between individual methods.\nIn a code review, this makes it harder to reason about what happens at a\nglance.</p><div><div><pre><code></code></pre></div></div><p>So, is this another post criticizing other dev practices? Not really. As\nalways, things exist on a spectrum and these previous examples show the two\nextremes.</p><p>As a developer, it can often feel more natural to write shallower interfaces.\nSimilar ‘shallow’ examples (that are not strictly interfaces) are the\n<a href=\"https://pkg.go.dev/github.com/aws/aws-sdk-go/aws/session#Options\">aws-sdk-go’s session Options</a> or\n<a href=\"https://github.com/spf13/viper/blob/d319333b0ffd91a9681feaf2d202ce9332df8ecc/viper.go\">Viper’s</a>\npublic API. Why?</p><ul><li>It makes methods smaller and easier to test</li><li>It maps more closely to the mental map of the system itself</li><li>It takes less time to think up-front about how the user will consume it</li><li>Usually, it only affords a single implementation, maybe two, so it’s easier\nto imagine how it will be used</li></ul><p>In contrast,  offers additional advantages:</p><ul><li>Can be easily retrofitted to other use cases</li><li>Requires no state checks to use properly</li><li>Interfaces like this tend to remain stable over time, while a shallower version would often grow to accommodate more and more features</li><li>It allows for natural composability into other abstractions, like a  or a </li></ul><div><div><pre><code>type ReadCloser interface {\n\tReader\n\tCloser\n}\n</code></pre></div></div><p>This not a  comparison, as you will rarely write such core functionality\nas the Reader from scratch, and well, Cmdable is not an abstraction but rather\na driver covering the entirety of Redis operations.</p><p>But still, does that client API  five different methods for saving and\nshutting down? Does a user of the client need to deal with both running\ncommands and getting meta-information around the DB connection and runtime\nmetrics at the same time? Is each of the datatypes different enough to have\ntheir own interface? And do I as a reviewer, need to know beforehand whether\nthe code needs to ,  or ?</p><p>So, next time you design or review an abstraction, take a closer look.\n<a href=\"https://www.youtube.com/watch?v=XpqqjU7u5Yc\">How “deep” is your API</a>?\nIn what ways could you mold it into something simpler that hides complexity\nfrom the user and reduces cognitive load?</p><p>And that’s all for today! If you have any comments, remarks or ideas, feel free\nto reach out to me on <a href=\"https://bsky.app/profile/tpaschalis.me\">Bluesky</a>.</p><p>What are your favorite interfaces? Any specific one that you think touches the\nPlatonic ideal? Any that disgusts you beyond imagination and makes you wanna\nquit, move to the countryside and grow tomatoes? Let me know!</p>","contentLength":4646,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1jhdapl/deep_vs_shallow_interfaces_in_go/"},{"title":"Easy to use SQL library","url":"https://www.reddit.com/r/golang/comments/1jh8uad/easy_to_use_sql_library/","date":1742651333,"author":"/u/pimpaa","guid":549,"unread":true,"content":"<p>Hello everyone, I've been working on something for a couple weeks now and wanted to share!</p><p>sqlz (naming is hard, I know) is a wrapper around  similar to sqlx. Primary features are:</p><ul><li>Easy to use: it has a simple API for everyday use that can handle several use cases.</li><li>Lightweight: performance similar to sqlx and only one dependency (it uses <a href=\"https://github.com/georgysavva/scany\">scany</a> under the hood to do the scanning job, which is also well optimized).</li><li>Support for non-english utf-8 characters in named queries.</li></ul><p>It has only 3 main methods that can handle different use cases:</p><p><code>go Query(ctx context.Context, dst any, query string, args ...any) error QueryRow(ctx context.Context, dst any, query string, args ...any) error Exec(ctx context.Context, query string, args ...any) (sql.Result, error) </code></p><p>Both / execute the query and scan the returned rows into the  parameter, it works with default or named placeholders, passing a struct or map as  works as a named query.</p><p> is similar, passing array/slice as  will be treated as a batch insert.</p><p>Let me know what y'all think, specially the API, do you think it's better to have a separate method for named queries? Been using it and it feels nice but want some inputs.</p><p>Obvious question so I'll answer in advance. I've been using sqlx for some time, and while it's miles ahead the stdlib, I feel it's too verbose for simple cases, e.g. can't use 'IN' clause with named queries directly, gotta first use sqlx.Named, handle the error, then sqlx.In, handle the error, then Rebind, then Select.</p><p>An abstraction on top of sqlx is not fun, so I took the opportunity to learn and created sqlz, which turned out pretty good.</p><p>Performance-wise, it's close to sqlx, you can see <a href=\"https://github.com/rfberaldo/sqlz/blob/master/benchmarks/results.txt\">results here</a> (lower delta is better for sqlz).</p>","contentLength":1702,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"More with pipelines","url":"https://www.reddit.com/r/golang/comments/1jh8gda/more_with_pipelines/","date":1742650153,"author":"/u/kwargs_","guid":546,"unread":true,"content":"<p>Fun update to share about the gliter✨ library. I recently pushed new stage handlers that unlock a variety of new powerful async pipeline patterns. Some of these were ideas you guys had in the comments of my original post (thank you!).</p><p>Most notable additions are `Merge` and `Option` stages. </p><pre><code>gliter.NewPipeline(streamFromRedis). Stage( preprocessFeatures, // Normalize, extract relevant fields ). Stage( runFraudModel, // Model inference on transactions checkBusinessRules, // Non-ML heuristic checks ). Merge( aggregateResults, // Combine outputs from ML &amp; rules ). Stage( sendToAlertSystem, // Notify if fraud detected storeInDatabase, // Log for later analysis ). Run() </code></pre><p>The elevator pitch is: Gliter (Golang iter) enables Go developers to express complex and nuanced async patterns without having to manage races, deadlocks, channel states, and goroutine leaks.</p><p>Actually just the other day, I encountered a deadlock scenario in some old code at work. If gliter becomes a thing, I can imagine a world where these types of painful bugs are much less common because the surface area of gnarly async code is reduced, centralized, and solved. That's what excites me about the project.</p><p>Anyway, if you're curious to read more about why I built gliter and what I learned along the way, the original blog post from a few months back is here:</p><p>Consider using gliter in your next project, I think you'll really enjoy it!</p>","contentLength":1408,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Will linking a Go program \"manually\" lose any optimizations?","url":"https://www.reddit.com/r/golang/comments/1jh6w2o/will_linking_a_go_program_manually_lose_any/","date":1742644922,"author":"/u/Forumpy","guid":548,"unread":true,"content":"<p>Generally, if I have a Go program of e.g. 3 packages, and I build it in such a way that each package is individually built in isolation, and then linked manually afterwards, would the resulting binary lose any optimizations that would've been there had the program been built entirely using simply ?</p>","contentLength":299,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How to create a github action to build Go binaries for Linux, Darwin and Windows in all archs?","url":"https://www.reddit.com/r/golang/comments/1jh4noo/how_to_create_a_github_action_to_build_go/","date":1742635591,"author":"/u/DarqOnReddit","guid":547,"unread":true,"content":"<p>I'm not sure if Darwin has other archs than x86_64. But Linux has at least amd64 and arm64 and so does Windows.</p><p>I never used Github actions and I have this Go repo where I'd like to provide prebuilt binaries for especially Windows users. It's a repo about live streaming and most run obs on Windows at home, so I'd like to make it as painless as possible for them to run my software.</p><p>I have googled but found nothing useful.</p><p>If you're using github and have a pure Go repo, how do you configure github actions to build binaries and turn those into downloadable releases?</p>","contentLength":566,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"GoAvatar – Generate Unique Identicons in Go (Highly Customizable!)","url":"https://www.reddit.com/r/golang/comments/1jh0ro7/goavatar_generate_unique_identicons_in_go_highly/","date":1742618748,"author":"/u/__muhammadsaim","guid":550,"unread":true,"content":"<p>I recently built <a href=\"https://github.com/MuhammadSaim/goavatar\">GoAvatar</a> – a lightweight Go package that generates unique, symmetric identicons based on input strings (like usernames, emails, or any text). It’s perfect for user avatars, profile placeholders, and visual identity generation!</p><ul><li>Deterministic Identicons – Same input = same avatar every time</li><li>Symmetric &amp; Unique Designs – Visually appealing, mirror-like patterns</li><li>Highly Customizable – Set size, colors, and more!</li><li>Fast &amp; Lightweight – Minimal dependencies for quick avatar generation</li></ul><p>import ( \"github.com/MuhammadSaim/goavatar\" \"image/png\" \"os\" \"image/color\" )</p><p>func main() { // Generate the avatar with a custom foreground and background color options := goavatar.Options{ Width: 128, // Set custom image width (default is 256) Height: 128, // Set custom image height (default is 256) BgColor: color.RGBA{170, 120, 10, 255}, // Change background color (default is light gray) FgColor: color.RGBA{255, 255, 255, 255}, // Change foreground color (default is extracted from hash) } avatar := goavatar.Make(\"EchoFrost7\", options)</p><pre><code>// Generates an avatar with a brownish background and white foreground, saving it as avatar.png file, err := os.Create(\"avatar.png\") if err != nil { panic(err) } defer file.Close() png.Encode(file, avatar) </code></pre><ul><li>Size: Adjust width and height as needed</li><li>Colors: Set custom foreground and background colors</li><li>Hashing Algorithm: Modify how identicons are generated</li></ul><p>Would love to hear your feedback or ideas for improvements!</p>","contentLength":1453,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","go"]}